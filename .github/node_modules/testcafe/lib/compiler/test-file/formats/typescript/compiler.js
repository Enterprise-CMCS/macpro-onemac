"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const typescript_configuration_1 = __importDefault(require("../../../../configuration/typescript-configuration"));
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', api_based_1.default.EXPORTABLE_LIB_PATH]]);
let TypeScriptTestFileCompiler = /** @class */ (() => {
    class TypeScriptTestFileCompiler extends api_based_1.default {
        constructor(compilerOptions = {}) {
            super();
            const tsConfigPath = compilerOptions.typeScriptOptions ? compilerOptions.typeScriptOptions.tsConfigPath : null;
            this.tsConfig = new typescript_configuration_1.default(tsConfigPath);
        }
        static _normalizeFilename(filename) {
            filename = path_1.default.resolve(filename);
            if (os_family_1.default.win)
                filename = filename.toLowerCase();
            return filename;
        }
        static _getTSDefsPath() {
            return TypeScriptTestFileCompiler._normalizeFilename(path_1.default.resolve(__dirname, '../../../../../ts-defs/index.d.ts'));
        }
        static _reportErrors(diagnostics) {
            // NOTE: lazy load the compiler
            const ts = require('typescript');
            let errMsg = 'TypeScript compilation failed.\n';
            diagnostics.forEach(d => {
                const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
                const file = d.file;
                if (file && d.start !== void 0) {
                    const { line, character } = file.getLineAndCharacterOfPosition(d.start);
                    errMsg += `${file.fileName} (${line + 1}, ${character + 1}): `;
                }
                errMsg += `${message}\n`;
            });
            throw new Error(errMsg);
        }
        _compileCodeForTestFiles(testFilesInfo) {
            return this.tsConfig.init()
                .then(() => {
                return super._compileCodeForTestFiles(testFilesInfo);
            });
        }
        _compileFilesToCache(ts, filenames) {
            const opts = this.tsConfig.getOptions();
            const program = ts.createProgram([TypeScriptTestFileCompiler.tsDefsPath, ...filenames], opts);
            program.getSourceFiles().forEach(sourceFile => {
                // @ts-ignore A hack to allow import globally installed TestCafe in tests
                sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
            });
            const diagnostics = ts.getPreEmitDiagnostics(program);
            if (diagnostics.length)
                TypeScriptTestFileCompiler._reportErrors(diagnostics);
            // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
            // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
            // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
            program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
                if (!sources)
                    return;
                const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
                this.cache[sourcePath] = result;
            });
        }
        _precompileCode(testFilesInfo) {
            // NOTE: lazy load the compiler
            const ts = require('typescript');
            const filenames = testFilesInfo.map(({ filename }) => filename);
            const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
            const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
            const uncachedFiles = normalizedFilenames
                .filter(filename => filename !== TypeScriptTestFileCompiler.tsDefsPath && !this.cache[filename])
                .map(filename => normalizedFilenamesMap[filename]);
            if (uncachedFiles.length)
                this._compileFilesToCache(ts, uncachedFiles);
            return normalizedFilenames.map(filename => this.cache[filename]);
        }
        _getRequireCompilers() {
            return {
                '.ts': (code, filename) => this._compileCode(code, filename),
                '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename)
            };
        }
        get canPrecompile() {
            return true;
        }
        getSupportedExtension() {
            return '.ts';
        }
    }
    TypeScriptTestFileCompiler.tsDefsPath = TypeScriptTestFileCompiler._getTSDefsPath();
    return TypeScriptTestFileCompiler;
})();
exports.default = TypeScriptTestFileCompiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFDekQsa0hBQXlGO0FBMkJ6RixNQUFNLHdCQUF3QixHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsbUJBQTRCLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFM0c7SUFBQSxNQUFxQiwwQkFBMkIsU0FBUSxtQkFBNEI7UUFLaEYsWUFBb0Isa0JBQW1DLEVBQUU7WUFDckQsS0FBSyxFQUFFLENBQUM7WUFFUixNQUFNLFlBQVksR0FBRyxlQUFlLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUUvRyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksa0NBQXVCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUVPLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBRSxRQUFnQjtZQUMvQyxRQUFRLEdBQUcsY0FBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVsQyxJQUFJLG1CQUFFLENBQUMsR0FBRztnQkFDTixRQUFRLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBRXRDLE9BQU8sUUFBUSxDQUFDO1FBQ3BCLENBQUM7UUFFTyxNQUFNLENBQUMsY0FBYztZQUN6QixPQUFPLDBCQUEwQixDQUFDLGtCQUFrQixDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLG1DQUFtQyxDQUFDLENBQUMsQ0FBQztRQUN2SCxDQUFDO1FBRU8sTUFB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LGNBQWMsRUFBRSxDQUFDO0lBZ0g1RSxpQ0FBQztLQUFBO2tCQWpIb0IsMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyB6aXBPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IE9TIGZyb20gJ29zLWZhbWlseSc7XG5pbXBvcnQgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZSBmcm9tICcuLi8uLi9hcGktYmFzZWQnO1xuaW1wb3J0IEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIgZnJvbSAnLi4vZXMtbmV4dC9jb21waWxlcic7XG5pbXBvcnQgVHlwZXNjcmlwdENvbmZpZ3VyYXRpb24gZnJvbSAnLi4vLi4vLi4vLi4vY29uZmlndXJhdGlvbi90eXBlc2NyaXB0LWNvbmZpZ3VyYXRpb24nO1xuXG4vLyBOT1RFOiBGb3IgdHlwZSBkZWZpbml0aW9ucyBvbmx5XG5pbXBvcnQgVHlwZVNjcmlwdCwgeyBDb21waWxlck9wdGlvbnNWYWx1ZSB9IGZyb20gJ3R5cGVzY3JpcHQnO1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vaW50ZXJmYWNlcyc7XG5cblxuZGVjbGFyZSB0eXBlIFR5cGVTY3JpcHRJbnN0YW5jZSA9IHR5cGVvZiBUeXBlU2NyaXB0O1xuXG5pbnRlcmZhY2UgQ29tcGlsZXJPcHRpb25zIHtcbiAgICB0eXBlU2NyaXB0T3B0aW9ucz86IHtcbiAgICAgICAgdHNDb25maWdQYXRoOiBzdHJpbmc7XG4gICAgfTtcbn1cblxuaW50ZXJmYWNlIFRlc3RGaWxlSW5mbyB7XG4gICAgZmlsZW5hbWU6IHN0cmluZztcbn1cblxuZGVjbGFyZSBpbnRlcmZhY2UgUmVxdWlyZUNvbXBpbGVyRnVuY3Rpb24ge1xuICAgIChjb2RlOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZXF1aXJlQ29tcGlsZXJzIHtcbiAgICBbZXh0ZW5zaW9uOiBzdHJpbmddOiBSZXF1aXJlQ29tcGlsZXJGdW5jdGlvbjtcbn1cblxuY29uc3QgUkVOQU1FRF9ERVBFTkRFTkNJRVNfTUFQID0gbmV3IE1hcChbWyd0ZXN0Y2FmZScsIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2UuRVhQT1JUQUJMRV9MSUJfUEFUSF1dKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIgZXh0ZW5kcyBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIHtcbiAgICBwcml2YXRlIHN0YXRpYyB0c0RlZnNQYXRoID0gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX2dldFRTRGVmc1BhdGgoKTtcblxuICAgIHByaXZhdGUgdHNDb25maWc6IFR5cGVzY3JpcHRDb25maWd1cmF0aW9uO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yIChjb21waWxlck9wdGlvbnM6IENvbXBpbGVyT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgY29uc3QgdHNDb25maWdQYXRoID0gY29tcGlsZXJPcHRpb25zLnR5cGVTY3JpcHRPcHRpb25zID8gY29tcGlsZXJPcHRpb25zLnR5cGVTY3JpcHRPcHRpb25zLnRzQ29uZmlnUGF0aCA6IG51bGw7XG5cbiAgICAgICAgdGhpcy50c0NvbmZpZyA9IG5ldyBUeXBlc2NyaXB0Q29uZmlndXJhdGlvbih0c0NvbmZpZ1BhdGgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIF9ub3JtYWxpemVGaWxlbmFtZSAoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGZpbGVuYW1lID0gcGF0aC5yZXNvbHZlKGZpbGVuYW1lKTtcblxuICAgICAgICBpZiAoT1Mud2luKVxuICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfZ2V0VFNEZWZzUGF0aCAoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vLi4vLi4vLi4vLi4vdHMtZGVmcy9pbmRleC5kLnRzJykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIF9yZXBvcnRFcnJvcnMgKGRpYWdub3N0aWNzOiBSZWFkb25seTxUeXBlU2NyaXB0LkRpYWdub3N0aWNbXT4pOiB2b2lkIHtcbiAgICAgICAgLy8gTk9URTogbGF6eSBsb2FkIHRoZSBjb21waWxlclxuICAgICAgICBjb25zdCB0czogVHlwZVNjcmlwdEluc3RhbmNlID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuICAgICAgICBsZXQgZXJyTXNnID0gJ1R5cGVTY3JpcHQgY29tcGlsYXRpb24gZmFpbGVkLlxcbic7XG5cbiAgICAgICAgZGlhZ25vc3RpY3MuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0cy5mbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGQubWVzc2FnZVRleHQsICdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgICAgPSBkLmZpbGU7XG5cbiAgICAgICAgICAgIGlmIChmaWxlICYmIGQuc3RhcnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGluZSwgY2hhcmFjdGVyIH0gPSBmaWxlLmdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uKGQuc3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGAke2ZpbGUuZmlsZU5hbWV9ICgke2xpbmUgKyAxfSwgJHtjaGFyYWN0ZXIgKyAxfSk6IGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVyck1zZyArPSBgJHttZXNzYWdlfVxcbmA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBfY29tcGlsZUNvZGVGb3JUZXN0RmlsZXMgKHRlc3RGaWxlc0luZm86IFRlc3RGaWxlSW5mb1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50c0NvbmZpZy5pbml0KClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuX2NvbXBpbGVDb2RlRm9yVGVzdEZpbGVzKHRlc3RGaWxlc0luZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29tcGlsZUZpbGVzVG9DYWNoZSAodHM6IFR5cGVTY3JpcHRJbnN0YW5jZSwgZmlsZW5hbWVzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvcHRzICAgID0gdGhpcy50c0NvbmZpZy5nZXRPcHRpb25zKCkgYXMgRGljdGlvbmFyeTxDb21waWxlck9wdGlvbnNWYWx1ZT47XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0cy5jcmVhdGVQcm9ncmFtKFtUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci50c0RlZnNQYXRoLCAuLi5maWxlbmFtZXNdLCBvcHRzKTtcblxuICAgICAgICBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaChzb3VyY2VGaWxlID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgQSBoYWNrIHRvIGFsbG93IGltcG9ydCBnbG9iYWxseSBpbnN0YWxsZWQgVGVzdENhZmUgaW4gdGVzdHNcbiAgICAgICAgICAgIHNvdXJjZUZpbGUucmVuYW1lZERlcGVuZGVuY2llcyA9IFJFTkFNRURfREVQRU5ERU5DSUVTX01BUDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSB0cy5nZXRQcmVFbWl0RGlhZ25vc3RpY3MocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9yZXBvcnRFcnJvcnMoZGlhZ25vc3RpY3MpO1xuXG4gICAgICAgIC8vIE5PVEU6IFRoZSBmaXJzdCBhcmd1bWVudCBvZiBlbWl0KCkgaXMgYSBzb3VyY2UgZmlsZSB0byBiZSBjb21waWxlZC4gSWYgaXQncyB1bmRlZmluZWQsIGFsbCBmaWxlcyBpblxuICAgICAgICAvLyA8cHJvZ3JhbT4gd2lsbCBiZSBjb21waWxlZC4gPHByb2dyYW0+IGNvbnRhaW5zIGEgZmlsZSBzcGVjaWZpZWQgaW4gY3JlYXRlUHJvZ3JhbSgpIHBsdXMgYWxsIGl0cyBkZXBlbmRlbmNpZXMuXG4gICAgICAgIC8vIFRoaXMgbW9kZSBpcyBtdWNoIGZhc3RlciB0aGFuIGNvbXBpbGluZyBmaWxlcyBvbmUtYnktb25lLCBhbmQgaXQgaXMgdXNlZCBpbiB0aGUgdHNjIENMSSBjb21waWxlci5cbiAgICAgICAgcHJvZ3JhbS5lbWl0KHZvaWQgMCwgKG91dHB1dE5hbWUsIHJlc3VsdCwgd3JpdGVCT00sIG9uRXJyb3IsIHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghc291cmNlcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBhdGggPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUoc291cmNlc1swXS5maWxlTmFtZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVbc291cmNlUGF0aF0gPSByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBfcHJlY29tcGlsZUNvZGUgKHRlc3RGaWxlc0luZm86IFRlc3RGaWxlSW5mb1tdKTogc3RyaW5nW10ge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzOiBUeXBlU2NyaXB0SW5zdGFuY2UgPSByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XG5cbiAgICAgICAgY29uc3QgZmlsZW5hbWVzICAgICAgICAgICAgICA9IHRlc3RGaWxlc0luZm8ubWFwKCh7IGZpbGVuYW1lIH0pID0+IGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZpbGVuYW1lcyAgICA9IGZpbGVuYW1lcy5tYXAoZmlsZW5hbWUgPT4gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX25vcm1hbGl6ZUZpbGVuYW1lKGZpbGVuYW1lKSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXNNYXAgPSB6aXBPYmplY3Qobm9ybWFsaXplZEZpbGVuYW1lcywgZmlsZW5hbWVzKTtcblxuICAgICAgICBjb25zdCB1bmNhY2hlZEZpbGVzID0gbm9ybWFsaXplZEZpbGVuYW1lc1xuICAgICAgICAgICAgLmZpbHRlcihmaWxlbmFtZSA9PiBmaWxlbmFtZSAhPT0gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIudHNEZWZzUGF0aCAmJiAhdGhpcy5jYWNoZVtmaWxlbmFtZV0pXG4gICAgICAgICAgICAubWFwKGZpbGVuYW1lID0+IG5vcm1hbGl6ZWRGaWxlbmFtZXNNYXBbZmlsZW5hbWVdKTtcblxuICAgICAgICBpZiAodW5jYWNoZWRGaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlRmlsZXNUb0NhY2hlKHRzLCB1bmNhY2hlZEZpbGVzKTtcblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVuYW1lcy5tYXAoZmlsZW5hbWUgPT4gdGhpcy5jYWNoZVtmaWxlbmFtZV0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBfZ2V0UmVxdWlyZUNvbXBpbGVycyAoKTogUmVxdWlyZUNvbXBpbGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnLnRzJzogKGNvZGUsIGZpbGVuYW1lKSA9PiB0aGlzLl9jb21waWxlQ29kZShjb2RlLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAnLmpzJzogKGNvZGUsIGZpbGVuYW1lKSA9PiBFU05leHRUZXN0RmlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvZGUuY2FsbCh0aGlzLCBjb2RlLCBmaWxlbmFtZSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGNhblByZWNvbXBpbGUgKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U3VwcG9ydGVkRXh0ZW5zaW9uICgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJy50cyc7XG4gICAgfVxufVxuIl19